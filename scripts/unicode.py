#!/usr/bin/env python2
# coding: utf-8

# Copyright ⓒ 2016 Daniel Keep.

# This script has been modified from the original (taken from the source of
# `regex-syntax` 0.2.2) to only contain the tables `scan-rules` actually cares
# about.  Someone remind me why this stuff isn't exposed in a crate somewhere?

# Copyright 2011-2013 The Rust Project Developers. See the COPYRIGHT
# file at the top-level directory of this distribution and at
# http://rust-lang.org/COPYRIGHT.
#
# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
# option. This file may not be copied, modified, or distributed
# except according to those terms.

# This script uses the following Unicode tables:
# - DerivedCoreProperties.txt
# - EastAsianWidth.txt
# - PropList.txt
# - Scripts.txt
# - UnicodeData.txt
#
# Since this should not require frequent updates, we just store this
# out-of-line and check the unicode.rs file into git.

from collections import defaultdict
import fileinput, re, os, shutil, sys, urllib2

preamble = '''/*
Copyright ⓒ 2016 Daniel Keep.

Licensed under the MIT license (see LICENSE or <http://opensource.org
/licenses/MIT>) or the Apache License, Version 2.0 (see LICENSE of
<http://www.apache.org/licenses/LICENSE-2.0>), at your option. All
files in the project carrying such notice may not be copied, modified,
or distributed except according to those terms.

NOTE: The following code was generated by "scripts/unicode.py", do not edit
directly.
*/
#![allow(non_upper_case_globals)]
'''

# Mapping taken from Table 12 from:
# http://www.unicode.org/reports/tr44/#General_Category_Values
expanded_categories = {
    'Lu': ['LC', 'L'], 'Ll': ['LC', 'L'], 'Lt': ['LC', 'L'],
    'Lm': ['L'], 'Lo': ['L'],
    'Mn': ['M'], 'Mc': ['M'], 'Me': ['M'],
    'Nd': ['N'], 'Nl': ['N'], 'No': ['No'],
    'Pc': ['P'], 'Pd': ['P'], 'Ps': ['P'], 'Pe': ['P'],
    'Pi': ['P'], 'Pf': ['P'], 'Po': ['P'],
    'Sm': ['S'], 'Sc': ['S'], 'Sk': ['S'], 'So': ['S'],
    'Zs': ['Z'], 'Zl': ['Z'], 'Zp': ['Z'],
    'Cc': ['C'], 'Cf': ['C'], 'Cs': ['C'], 'Co': ['C'], 'Cn': ['C'],
}

def fetch(f):
    if not os.path.exists('local'):
        os.mkdir('local')
    out_path = os.path.join('local', f)
    if not os.path.exists(out_path):
        sys.stdout.write('Fetching %s...\n' % f)
        res = urllib2.urlopen("http://www.unicode.org/Public/UNIDATA/%s" % f)
        out = open(out_path, 'w')
        shutil.copyfileobj(res, out)
    return out_path

def is_surrogate(n):
    return 0xD800 <= n <= 0xDFFF

def load_unicode_data(f):
    f = fetch(f)
    gencats = {}

    udict = {};
    range_start = -1;
    for line in fileinput.input(f):
        data = line.split(';');
        if len(data) != 15:
            continue
        cp = int(data[0], 16);
        if is_surrogate(cp):
            continue
        if range_start >= 0:
            for i in xrange(range_start, cp):
                udict[i] = data;
            range_start = -1;
        if data[1].endswith(", First>"):
            range_start = cp;
            continue;
        udict[cp] = data;

    for code in udict:
        [code_org, name, gencat, combine, bidi,
         decomp, deci, digit, num, mirror,
         old, iso, upcase, lowcase, titlecase ] = udict[code];

        # place letter in categories as appropriate
        for cat in [gencat, "Assigned"] + expanded_categories.get(gencat, []):
            if cat not in gencats:
                gencats[cat] = []
            gencats[cat].append(code)

    # generate Not_Assigned from Assigned
    gencats["Cn"] = gen_unassigned(gencats["Assigned"])
    # Assigned is not a real category
    del(gencats["Assigned"])
    # Other contains Not_Assigned
    gencats["C"].extend(gencats["Cn"])
    gencats = group_cats(gencats)

    return gencats

def group_cats(cats):
    cats_out = {}
    for cat in cats:
        cats_out[cat] = group_cat(cats[cat])
    return cats_out

def group_cat(cat):
    cat_out = []
    letters = sorted(set(cat))
    cur_start = letters.pop(0)
    cur_end = cur_start
    for letter in letters:
        assert letter > cur_end, \
            "cur_end: %s, letter: %s" % (hex(cur_end), hex(letter))
        if letter == cur_end + 1:
            cur_end = letter
        else:
            cat_out.append((cur_start, cur_end))
            cur_start = cur_end = letter
    cat_out.append((cur_start, cur_end))
    return cat_out

def ungroup_cat(cat):
    cat_out = []
    for (lo, hi) in cat:
        while lo <= hi:
            cat_out.append(lo)
            lo += 1
    return cat_out

def gen_unassigned(assigned):
    assigned = set(assigned)
    return ([i for i in range(0, 0xd800) if i not in assigned] +
            [i for i in range(0xe000, 0x110000) if i not in assigned])

def format_table_content(f, content, indent):
    line = " "*indent
    first = True
    for chunk in content.split(","):
        if len(line) + len(chunk) < 78:
            if first:
                line += chunk
            else:
                line += ", " + chunk
            first = False
        else:
            f.write(line + ",\n")
            line = " "*indent + chunk
    f.write(line)

def load_properties(f, interestingprops):
    f = fetch(f)
    props = {}
    re1 = re.compile("^ *([0-9A-F]+) *; *(\w+)")
    re2 = re.compile("^ *([0-9A-F]+)\.\.([0-9A-F]+) *; *(\w+)")

    for line in fileinput.input(f):
        prop = None
        d_lo = 0
        d_hi = 0
        m = re1.match(line)
        if m:
            d_lo = m.group(1)
            d_hi = m.group(1)
            prop = m.group(2)
        else:
            m = re2.match(line)
            if m:
                d_lo = m.group(1)
                d_hi = m.group(2)
                prop = m.group(3)
            else:
                continue
        if interestingprops and prop not in interestingprops:
            continue
        d_lo = int(d_lo, 16)
        d_hi = int(d_hi, 16)
        if prop not in props:
            props[prop] = []
        props[prop].append((d_lo, d_hi))

    # optimize props if possible
    for prop in props:
        props[prop] = group_cat(ungroup_cat(props[prop]))

    return props

def load_case_folding(f):
    f = fetch(f)
    re1 = re.compile("^ *([0-9A-F]+) *; *[CS] *; *([0-9A-F]+) *;")
    all_pairs = defaultdict(list)
    for line in fileinput.input(f):
        m = re1.match(line)
        if m:
            a = int(m.group(1), 16)
            b = int(m.group(2), 16)
            all_pairs[a].append(b)
            all_pairs[b].append(a)
    both = set()
    for k, vs in all_pairs.iteritems():
        for v in vs:
            both.add((k, v))
            for v2 in all_pairs[v]:
                both.add((k, v2))
    c_plus_s_both = sorted((k1, k2) for k1, k2 in both if k1 != k2)
    return {"C_plus_S_both": c_plus_s_both}

def escape_char(c):
    return "'\\u{%x}'" % c

def emit_table(f, name, t_data, t_type = "&'static [(char, char)]", is_pub=True,
        pfun=lambda x: "(%s,%s)" % (escape_char(x[0]), escape_char(x[1]))):
    pub_string = ""
    if is_pub:
        pub_string = "pub "
    f.write("    %sconst %s: %s = &[\n" % (pub_string, name, t_type))
    data = ""
    first = True
    for dat in t_data:
        if not first:
            data += ","
        first = False
        data += pfun(dat)
    format_table_content(f, data, 8)
    f.write("\n    ];\n\n")

def emit_property_module(f, mod, tbl):
    f.write("pub mod %s {\n" % mod)
    keys = tbl.keys()
    keys.sort()
    for cat in keys:
        emit_table(f, "%s_table" % cat, tbl[cat])
    f.write("}\n\n")

def emit_regex_module(f, cats, w_data):
    f.write("pub mod regex {\n")
    regex_class = "&'static [(char, char)]"
    class_table = "&'static [(&'static str, %s)]" % regex_class

    emit_table(f, "PERLW", w_data, regex_class)

    f.write("}\n\n")

if __name__ == "__main__":
    r = "src/unicode.rs"
    if os.path.exists(r):
        os.remove(r)
    with open(r, "w") as rf:
        # write the file's preamble
        rf.write(preamble)

        # download and parse all the data
        with open(fetch("ReadMe.txt")) as readme:
            pattern = "for Version (\d+)\.(\d+)\.(\d+) of the Unicode"
            unicode_version = re.search(pattern, readme.read()).groups()
        gencats = load_unicode_data("UnicodeData.txt")
        want_derived = ["XID_Start", "XID_Continue", "Alphabetic"]
        other_derived = []
        derived = load_properties("DerivedCoreProperties.txt", want_derived + other_derived)
        scripts = load_properties("Scripts.txt", [])
        props = load_properties("PropList.txt",
                ["White_Space", "Join_Control", "Noncharacter_Code_Point"])
        case_folding = load_case_folding("CaseFolding.txt")

        # all of these categories will also be available as \p{} in libregex
        allcats = []
        for (name, cat, filter) in [
            ("general_category", gencats, lambda n: n == "Nd"),
            ("derived_property", derived, lambda n: n in ("XID_Start", "XID_Continue")),
            ("property", props, lambda n: n == "White_Space"),
        ]:
            emit_property_module(rf, name,
                dict((k,cat[k]) for k in cat
                    if filter(k))
                )
            allcats.extend(map(lambda x: (x, name), cat))
        allcats.sort(key=lambda c: c[0])

        # the \w regex corresponds to Alphabetic + Mark + Decimal_Number +
        # Connector_Punctuation + Join-Control according to UTS#18
        # http://www.unicode.org/reports/tr18/#Compatibility_Properties
        perl_words = []
        for cat in derived["Alphabetic"], gencats["M"], gencats["Nd"], \
                   gencats["Pc"], props["Join_Control"]:
            perl_words.extend(ungroup_cat(cat))
        perl_words = group_cat(perl_words)

        # emit lookup tables for \p{}, along with \d, \w, and \s for libregex
        emit_regex_module(rf, allcats, perl_words)
